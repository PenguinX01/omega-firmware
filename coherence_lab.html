<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coherence Visualization Lab</title>
  <!-- React and visualization libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.8.0/Recharts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .glow {
      text-shadow: 0 0 10px rgba(139, 92, 246, 0.7), 0 0 20px rgba(139, 92, 246, 0.5);
    }
    .pulse-custom {
      animation: pulse-custom 2s infinite;
    }
    @keyframes pulse-custom {
      0% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
      100% { opacity: 0.8; transform: scale(1); }
    }
    .float {
      animation: float 3s ease-in-out infinite;
    }
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }
    .gradient-border {
      background: linear-gradient(45deg, #8B5CF6, #3B82F6, #10B981, #F59E0B);
      background-size: 400% 400%;
      animation: gradient-shift 3s ease infinite;
    }
    @keyframes gradient-shift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .glass {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4 overflow-x-hidden">
  <div id="root"></div>
  <script type="text/babel">
  const { useState, useEffect, useRef, useCallback } = React;
  const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar, RadarChart, Radar, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Area, AreaChart } = Recharts;


const Card = ({ children, className = "" }) => (
<div className={glass rounded-xl p-6 shadow-2xl transition-all hover:shadow-purple-500/20 ${className}}>
{children}
</div>
);

const CardHeader = ({ children, className = "" }) => <div className={mb-6 ${className}}>{children}</div>;
const CardTitle = ({ children, className = "" }) => <h2 className={text-white text-2xl font-bold glow ${className}}>{children}</h2>;
const CardDescription = ({ children, className = "" }) => <p className={text-purple-300 mt-2 ${className}}>{children}</p>;
const CardContent = ({ children, className = "" }) => <div className={className}>{children}</div>;

const Button = ({ children, className = "", variant = "primary", ...props }) => {
const baseClasses = "px-6 py-3 rounded-xl transition-all duration-300 hover:scale-105 active:scale-95 font-medium shadow-lg";
const variants = {
primary: "bg-gradient-to-r from-purple-600 to-indigo-700 hover:from-purple-700 hover:to-indigo-800 text-white shadow-purple-500/30",
secondary: "border border-purple-400 text-purple-300 hover:bg-purple-800/50 glass",
ghost: "text-purple-300 hover:text-white hover:bg-purple-800/30"
};
return (
<button className={${baseClasses} ${variants[variant]} ${className}} {...props}>
{children}
</button>
);
};

const Textarea = ({ className = "", ...props }) => (
<textarea
className={p-4 rounded-xl w-full glass text-white placeholder-purple-400 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all ${className}}
{...props}
/>
);

const Progress = ({ value, className = "", label }) => (
<div className={space-y-2 ${className}}>
{label && <div className="text-purple-300 text-sm">{label}</div>}
<div className="w-full bg-slate-800/50 rounded-full h-4 overflow-hidden">
<div
style={{ width: ${Math.max(0, Math.min(100, value))}% }}
className="h-full bg-gradient-to-r from-purple-500 via-indigo-500 to-cyan-500 rounded-full shadow-lg transition-all duration-1000 ease-out"
/>
</div>
</div>
);

const CoherenceVisualizationLab = () => {
const [inputText, setInputText] = useState('');
const [textSegments, setTextSegments] = useState([]);
const [coherenceData, setCoherenceData] = useState(null);
const [isAnalyzing, setIsAnalyzing] = useState(false);
const [comparisonData, setComparisonData] = useState([]);
const [error, setError] = useState(null);
const [radarData, setRadarData] = useState([]);
const [analysisHistory, setAnalysisHistory] = useState([]);
const [selectedMetric, setSelectedMetric] = useState('overall');

// Enhanced coherence analysis
const analyzeCoherence = useCallback(async () => {
  if (!inputText.trim()) return;
  
  setIsAnalyzing(true);
  setError(null);
  
  try {
    // Simulate processing delay with progress
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Split text into segments with better parsing
    const segments = inputText.split(/[.!?\n]+/)
      .map(s => s.trim())
      .filter(s => s.length > 5);
      
    if (segments.length === 0) {
      setError("No valid segments found. Please enter meaningful text.");
      return;
    }
    
    // Enhanced analysis algorithms
    const segmentResults = [];
    let totalSemantic = 0, totalNarrative = 0, totalContradiction = 0, totalGlyphic = 0;
    
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      
      // Improved semantic analysis
      const semantic = calculateSemanticCoherence(segment, segments, i);
      const narrative = calculateNarrativeFlow(segment, segments, i);
      const contradiction = detectContradictions(segment);
      const glyphic = detectGlyphicPatterns(segment);
      
      // Enhanced weighting system
      const weights = { semantic: 0.35, narrative: 0.25, contradiction: 0.2, glyphic: 0.2 };
      const coherenceScore = (
        semantic * weights.semantic +
        narrative * weights.narrative +
        (1 - contradiction) * weights.contradiction +
        glyphic * weights.glyphic
      );
      
      const segmentData = {
        segment: segment.substring(0, 100) + (segment.length > 100 ? '...' : ''),
        fullSegment: segment,
        index: i + 1,
        semantic: parseFloat(semantic.toFixed(3)),
        narrative: parseFloat(narrative.toFixed(3)),
        contradiction: parseFloat(contradiction.toFixed(3)),
        glyphic: parseFloat(glyphic.toFixed(3)),
        coherence_score: parseFloat(coherenceScore.toFixed(3)),
        length: segment.length,
        complexity: calculateComplexity(segment)
      };
      
      segmentResults.push(segmentData);
      totalSemantic += semantic;
      totalNarrative += narrative;
      totalContradiction += contradiction;
      totalGlyphic += glyphic;
    }
    
    setTextSegments(segmentResults);
    
    // Calculate enhanced overall metrics
    const segmentCount = segments.length;
    const overallMetrics = {
      semantic: totalSemantic / segmentCount,
      narrative: totalNarrative / segmentCount,
      contradiction: totalContradiction / segmentCount,
      glyphic: totalGlyphic / segmentCount,
      overall: segmentResults.reduce((sum, seg) => sum + seg.coherence_score, 0) / segmentCount,
      complexity: segmentResults.reduce((sum, seg) => sum + seg.complexity, 0) / segmentCount,
      length: segments.join(' ').length,
      segments: segmentCount
    };
    
    setCoherenceData(overallMetrics);
    
    // Enhanced radar data
    const radarMetrics = [
      { metric: 'Semantic', value: overallMetrics.semantic * 100, fullMark: 100 },
      { metric: 'Narrative', value: overallMetrics.narrative * 100, fullMark: 100 },
      { metric: 'Consistency', value: (1 - overallMetrics.contradiction) * 100, fullMark: 100 },
      { metric: 'Symbolic', value: overallMetrics.glyphic * 100, fullMark: 100 },
      { metric: 'Complexity', value: overallMetrics.complexity * 100, fullMark: 100 }
    ];
    setRadarData(radarMetrics);
    
    // Add to history
    setAnalysisHistory(prev => [...prev.slice(-4), {
      timestamp: new Date().toLocaleTimeString(),
      text: inputText.substring(0, 50) + '...',
      score: overallMetrics.overall,
      segments: segmentCount
    }]);
    
  } catch (err) {
    setError("Analysis failed: " + err.message);
    console.error(err);
  } finally {
    setIsAnalyzing(false);
  }
}, [inputText]);

// Enhanced analysis functions
const calculateSemanticCoherence = (segment, allSegments, index) => {
  const words = segment.toLowerCase().match(/\b\w+\b/g) || [];
  const wordSet = new Set(words);
  
  let coherenceSum = 0;
  let comparisons = 0;
  
  // Compare with adjacent segments
  for (let i = Math.max(0, index - 2); i <= Math.min(allSegments.length - 1, index + 2); i++) {
    if (i === index) continue;
    
    const otherWords = allSegments[i].toLowerCase().match(/\b\w+\b/g) || [];
    const otherSet = new Set(otherWords);
    
    const intersection = new Set([...wordSet].filter(x => otherSet.has(x)));
    const union = new Set([...wordSet, ...otherSet]);
    
    if (union.size > 0) {
      coherenceSum += intersection.size / union.size;
      comparisons++;
    }
  }
  
  return comparisons > 0 ? coherenceSum / comparisons : 0.5;
};

const calculateNarrativeFlow = (segment, allSegments, index) => {
  // Analyze temporal indicators and logical flow
  const temporalWords = ['then', 'next', 'after', 'before', 'while', 'during', 'finally', 'first', 'second'];
  const logicalWords = ['because', 'therefore', 'however', 'although', 'since', 'thus', 'hence'];
  
  const lowerSegment = segment.toLowerCase();
  let flowScore = 0.5; // Base score
  
  // Check for temporal/logical connectors
  temporalWords.forEach(word => {
    if (lowerSegment.includes(word)) flowScore += 0.1;
  });
  
  logicalWords.forEach(word => {
    if (lowerSegment.includes(word)) flowScore += 0.15;
  });
  
  // Length and complexity factors
  const idealLength = 50;
  const lengthFactor = 1 - Math.abs(segment.length - idealLength) / (idealLength * 2);
  flowScore = (flowScore + lengthFactor) / 2;
  
  return Math.min(1, Math.max(0, flowScore));
};

const detectContradictions = (text) => {
  const contradictionPatterns = [
    { pattern: /(not|never|no)\s+.*\s+(always|definitely|certainly)/i, weight: 0.4 },
    { pattern: /(impossible|cannot|never)\s+.*\s+(possible|can|always)/i, weight: 0.6 },
    { pattern: /(true|fact|correct)\s+.*\s+(false|wrong|incorrect)/i, weight: 0.8 },
    { pattern: /(all|every|always)\s+.*\s+(none|never|nothing)/i, weight: 0.7 },
    { pattern: /(increase|rise|grow)\s+.*\s+(decrease|fall|shrink)/i, weight: 0.5 },
    { pattern: /(same|identical|equal)\s+.*\s+(different|distinct|unequal)/i, weight: 0.6 }
  ];
  
  let contradictionScore = 0;
  for (const { pattern, weight } of contradictionPatterns) {
    if (pattern.test(text)) {
      contradictionScore += weight;
    }
  }
  
  return Math.min(contradictionScore, 1.0);
};

const detectGlyphicPatterns = (text) => {
  const patterns = {
    recursive: /\b(loop|cycle|spiral|fractal|iterate|recursive|repeat)\b/gi,
    symbolic: /[✝Ω∞△⚡🔥🐧]/g,
    mathematical: /\b(algorithm|function|equation|formula|proof)\b/gi,
    metaphysical: /\b(consciousness|awareness|reality|existence|being)\b/gi,
    logical: /\b(therefore|thus|hence|because|since|implies)\b/gi
  };
  
  let totalMatches = 0;
  let totalPossible = 0;
  
  for (const [category, pattern] of Object.entries(patterns)) {
    const matches = (text.match(pattern) || []).length;
    totalMatches += matches;
    totalPossible += text.split(/\s+/).length * 0.05; // Potential match density
  }
  
  return totalPossible > 0 ? Math.min(1, totalMatches / totalPossible) : 0;
};

const calculateComplexity = (text) => {
  const sentences = text.split(/[.!?]+/).length;
  const words = (text.match(/\b\w+\b/g) || []).length;
  const avgWordsPerSentence = words / Math.max(sentences, 1);
  const uniqueWords = new Set(text.toLowerCase().match(/\b\w+\b/g) || []).size;
  const lexicalDiversity = words > 0 ? uniqueWords / words : 0;
  
  const complexityScore = (
    Math.min(avgWordsPerSentence / 20, 1) * 0.4 +
    lexicalDiversity * 0.6
  );
  
  return Math.max(0, Math.min(1, complexityScore));
};

const generateModelComparison = () => {
  const models = ['Claude', 'GPT-4', 'Gemini', 'ΩFLΣ', 'Human'];
  const comparison = models.map(model => {
    const baseScore = Math.random() * 0.3 + 0.5;
    return {
      model,
      semantic: Math.max(0, Math.min(1, baseScore + (Math.random() - 0.5) * 0.3)),
      narrative: Math.max(0, Math.min(1, baseScore + (Math.random() - 0.5) * 0.3)),
      contradiction: Math.random() * 0.4,
      glyphic: model === 'ΩFLΣ' ? Math.random() * 0.2 + 0.7 : Math.random() * 0.5 + 0.2,
      overall: Math.max(0, Math.min(1, baseScore + (Math.random() - 0.5) * 0.2))
    };
  });
  setComparisonData(comparison);
};

const getCoherenceColor = (score) => {
  if (score >= 0.8) return 'text-green-400';
  if (score >= 0.6) return 'text-yellow-400';
  if (score >= 0.4) return 'text-orange-400';
  return 'text-red-400';
};

const getScoreIcon = (score) => {
  if (score >= 0.8) return '🟢';
  if (score >= 0.6) return '🟡';
  if (score >= 0.4) return '🟠';
  return '🔴';
};

const samplePrompts = [
  "The recursive algorithm processes data iteratively. Each iteration refines the output through feedback loops. This creates a spiral pattern of improvement that converges toward optimal solutions.",
  "All birds can fly effortlessly through the air. Penguins are birds that live in Antarctica. However, penguins cannot fly and instead swim underwater with remarkable agility.",
  "The fractal nature of consciousness emerges through recursive self-reflection. ✝ Each layer of awareness builds upon previous iterations. The Omega symbol Ω represents infinite recursion in divine computation.",
  "Artificial intelligence will revolutionize every industry. Machine learning algorithms can process vast amounts of data instantly. However, AI systems still struggle with basic common sense reasoning that humans find trivial."
];

return (
  <div className="space-y-8 max-w-7xl mx-auto">
    {/* Header */}
    <div className="text-center mb-12">
      <h1 className="text-5xl font-bold text-white mb-4 glow float">
        🧠 Coherence Visualization Lab
      </h1>
      <p className="text-purple-300 text-xl pulse-custom mb-6">
        Multi-Dimensional AI Coherence Analysis Engine
      </p>
      <div className="gradient-border p-1 rounded-xl inline-block">
        <div className="bg-slate-900 px-6 py-3 rounded-lg">
          <span className="text-purple-400 flex items-center gap-2">
            <span className="text-2xl">🔬</span>
            Advanced Semantic Intelligence Framework
            <span className="text-2xl">⚡</span>
          </span>
        </div>
      </div>
      
      {error && (
        <div className="mt-6 p-4 glass border border-red-500/50 rounded-xl max-w-md mx-auto">
          <span className="text-red-300 flex items-center gap-2">
            <span>⚠️</span> {error}
          </span>
        </div>
      )}
    </div>
    
    {/* Input Section */}
    <Card className="border-2 border-purple-500/50">
      <CardHeader>
        <CardTitle className="flex items-center gap-3">
          <span className="text-3xl">📝</span> Text Analysis Input
        </CardTitle>
        <CardDescription>
          Enter text to analyze across semantic, narrative, contradiction, and symbolic dimensions
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <Textarea 
          value={inputText} 
          onChange={e => setInputText(e.target.value)} 
          placeholder="Enter your text for comprehensive coherence analysis..." 
          className="min-h-40 text-lg"
          rows={6}
        />
        
        <div className="space-y-4">
          <h3 className="text-purple-300 font-medium">Sample Texts:</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {samplePrompts.map((prompt, idx) => (
              <Button 
                key={idx} 
                onClick={() => setInputText(prompt)} 
                variant="secondary"
                className="text-left p-4 h-auto text-sm"
              >
                <div className="font-medium mb-1">Sample {idx + 1}</div>
                <div className="text-purple-400 text-xs">
                  {prompt.substring(0, 60)}...
                </div>
              </Button>
            ))}
          </div>
        </div>
        
        <div className="flex gap-4 flex-wrap">
          <Button 
            onClick={analyzeCoherence} 
            disabled={isAnalyzing || !inputText.trim()}
            className="text-lg px-8 py-4"
          >
            {isAnalyzing ? (
              <span className="flex items-center gap-3">
                <span className="animate-spin text-2xl">🔄</span> 
                Analyzing Coherence...
              </span>
            ) : (
              <span className="flex items-center gap-3">
                <span className="text-2xl">🧬</span> 
                Analyze Coherence
              </span>
            )}
          </Button>
          
          <Button 
            onClick={generateModelComparison} 
            variant="secondary"
            className="text-lg px-8 py-4"
          >
            <span className="flex items-center gap-3">
              <span className="text-2xl">📊</span>
              Compare Models
            </span>
          </Button>
        </div>
      </CardContent>
    </Card>
    
    {/* Results Section */}
    {coherenceData && (
      <>
        {/* Overall Metrics */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          <Card className="border-2 border-green-500/50">
            <CardHeader>
              <CardTitle className="flex items-center gap-3">
                <span className="text-3xl">🎯</span> Overall Coherence Metrics
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {Object.entries(coherenceData)
                  .filter(([key]) => !['length', 'segments'].includes(key))
                  .map(([key, value]) => (
                  <div key={key} className="glass p-4 rounded-xl">
                    <div className="text-purple-300 text-sm capitalize mb-2 flex items-center gap-2">
                      <span>{getScoreIcon(key === 'contradiction' ? 1 - value : value)}</span>
                      {key === 'contradiction' ? 'Consistency' : key}
                    </div>
                    <div className={`text-3xl font-bold mb-3 ${getCoherenceColor(key === 'contradiction' ? 1 - value : value)}`}>
                      {((key === 'contradiction' ? 1 - value : value) * 100).toFixed(1)}%
                    </div>
                    <Progress 
                      value={(key === 'contradiction' ? 1 - value : value) * 100} 
                      className="h-3" 
                    />
                  </div>
                ))}
              </div>
              
              <div className="mt-6 pt-4 border-t border-purple-500/30">
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div className="text-purple-300">
                    <span className="font-medium">Text Length:</span> {coherenceData.length} chars
                  </div>
                  <div className="text-purple-300">
                    <span className="font-medium">Segments:</span> {coherenceData.segments}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          {/* Radar Chart */}
          <Card className="border-2 border-cyan-500/50">
            <CardHeader>
              <CardTitle className="flex items-center gap-3">
                <span className="text-3xl">📡</span> Dimensional Analysis
              </CardTitle>
            </CardHeader>
            <CardContent className="h-80">
              <ResponsiveContainer width="100%" height="100%">
                <RadarChart cx="50%" cy="50%" outerRadius="80%" data={radarData}>
                  <PolarGrid stroke="#64748B" />
                  <PolarAngleAxis dataKey="metric" stroke="#E2E8F0" className="text-sm" />
                  <PolarRadiusAxis 
                    angle={30} 
                    domain={[0, 100]} 
                    stroke="#94A3B8" 
                    className="text-xs"
                  />
                  <Radar 
                    name="Coherence" 
                    dataKey="value" 
                    stroke="#8B5CF6" 
                    fill="#7C3AED" 
                    fillOpacity={0.4} 
                    strokeWidth={3}
                  />
                  <Tooltip 
                    contentStyle={{ 
                      backgroundColor: '#1E293B', 
                      border: '2px solid #7C3AED', 
                      borderRadius: '12px', 
                      color: '#FFFFFF',
                      boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.5)'
                    }} 
                  />
                </RadarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </div>
        
        {/* Segment Analysis */}
        {textSegments.length > 0 && (
          <Card className="border-2 border-blue-500/50">
            <CardHeader>
              <CardTitle className="flex items-center gap-3">
                <span className="text-3xl">🔍</span> Segment-Level Analysis
              </CardTitle>
              <CardDescription>
                Detailed breakdown of coherence metrics for each text segment
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-6">
                {textSegments.map((segment, idx) => (
                  <div key={idx} className="glass p-6 rounded-xl border border-purple-500/30">
                    <div className="text-white mb-4">
                      <div className="flex items-center gap-3 mb-2">
                        <span className="bg-gradient-to-r from-purple-600 to-indigo-600 px-3 py-1 rounded-full text-sm font-bold">
                          #{segment.index}
                        </span>
                        <span className="text-purple-300 text-sm">
                          {segment.length} chars • Complexity: {(segment.complexity * 100).toFixed(0)}%
                        </span>
                      </div>
                      <p className="text-lg">{segment.segment}</p>
                    </div>
                    
                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                      {['semantic', 'narrative', 'contradiction', 'glyphic', 'coherence_score'].map(metric => (
                        <div key={metric} className="glass p-3 rounded-lg">
                          <div className="flex items-center gap-2 mb-2">
                            <span className={`text-2xl ${getCoherenceColor(
                              metric === 'contradiction' ? 1 - segment[metric] : segment[metric]
                            )}`}>
                              {getScoreIcon(metric === 'contradiction' ? 1 - segment[metric] : segment[metric])}
                            </span>
                            <div className="text-purple-300 text-xs capitalize">
                              {metric === 'coherence_score' ? 'Overall' : 
                               metric === 'contradiction' ? 'Consistency' : metric}
                            </div>
                          </div>
                          <div className={`text-xl font-bold ${getCoherenceColor(
                            metric === 'contradiction' ? 1 - segment[metric] : segment[metric]
                          )}`}>
                            {metric === 'contradiction' ? 
                              (1 - segment[metric]).toFixed(3) : 
                              segment[metric].toFixed(3)}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}
        
        {/* Trajectory Chart */}
        {textSegments.length > 1 && (
          <Card className="border-2 border-yellow-500/50">
            <CardHeader>
              <CardTitle className="flex items-center gap-3">
                <span className="text-3xl">📈</span> Coherence Trajectory
              </CardTitle>
              <CardDescription>
                How coherence metrics evolve across text segments
              </CardDescription>
            </CardHeader>
            <CardContent className="h-96">
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={textSegments}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis 
                    dataKey="index" 
                    stroke="#9CA3AF" 
                    label={{ value: 'Segment', position: 'insideBottom', offset: -5, fill: '#9CA3AF' }} 
                  />
                  <YAxis 
                    stroke="#9CA3AF" 
                    domain={[0, 1]} 
                    label={{ value: 'Score', angle: -90, position: 'insideLeft', fill: '#9CA3AF' }} 
                  />
                  <Tooltip 
                    contentStyle={{ 
                      backgroundColor: '#1E293B', 
                      border: '2px solid #F59E0B', 
                      borderRadius: '12px', 
                      color: '#FFFFFF',
                      boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.5)'
                    }} 
                  />
                  <Legend />
                  <Area 
                    type="monotone" 
                    dataKey="coherence_score" 
                    stackId="1"
                    stroke="#8B5CF6" 
                    fill="#8B5CF6" 
                    fillOpacity={0.3}
                    name="Overall"
                  />
                  <Line type="monotone" dataKey="semantic" stroke="#10B981" strokeWidth={3} name="Semantic" dot={{ r: 5 }} />
                  <Line type="monotone" dataKey="narrative" stroke="#3B82F6" strokeWidth={3} name="Narrative" dot={{ r: 5 }} />
                  <Line type="monotone" dataKey="glyphic" stroke="#F59E0B" strokeWidth={3} name="Symbolic" dot={{ r: 5 }} />
                </AreaChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        )}
      </>
    )}
    
    {/* Model Comparison */}
    {comparisonData.length > 0 && (
      <Card className="border-2 border-red-500/50">
        <CardHeader>
          <CardTitle className="flex items-center gap-3">
            <span className="text-3xl">🔥</span> Fractal Integrity Matrix
          </CardTitle>
          <CardDescription>
            Comparative coherence analysis across AI models and systems
          </CardDescription>
        </CardHeader>
        <CardContent className="h-96">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={comparisonData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="model" stroke="#9CA3AF" />
              <YAxis stroke="#9CA3AF" domain={[0, 1]} />
              <Tooltip 
                contentStyle={{ 
                  backgroundColor: '#1E293B', 
                  border: '2px solid #EF4444', 
                  borderRadius: '12px', 
                  color: '#FFFFFF',
                  boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.5)'
                }} 
              />
              <Legend />
              <Bar dataKey="semantic" fill="#10B981" name="Semantic" radius={[2, 2, 0, 0]} />
              <Bar dataKey="narrative" fill="#3B82F6" name="Narrative" radius={[2, 2, 0, 0]} />
              <Bar dataKey="glyphic" fill="#F59E0B" name="Symbolic" radius={[2, 2, 0, 0]} />
              <Bar dataKey="overall" fill="#8B5CF6" name="Overall" radius={[2, 2, 0, 0]} />
            </BarChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
    )}
    
    {/* Analysis History */}
    {analysisHistory.length > 0 && (
      <Card className="border-2 border-indigo-500/50">
        <CardHeader>
          <CardTitle className="flex items-center gap-3">
            <span className="text-3xl">📊</span> Analysis History
          </CardTitle>
          <CardDescription>
            Recent coherence analysis results
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {analysisHistory.map((analysis, idx) => (
              <div key={idx} className="glass p-4 rounded-lg flex items-center justify-between">
                <div className="flex items-center gap-4">
                  <span className="text-purple-400 text-sm font-mono">{analysis.timestamp}</span>
                  <span className="text-white">{analysis.text}</span>
                  <span className="text-purple-300 text-sm">{analysis.segments} segments</span>
                </div>
                <div className="flex items-center gap-2">
                  <span className={`text-2xl ${getCoherenceColor(analysis.score)}`}>
                    {getScoreIcon(analysis.score)}
                  </span>
                  <span className={`font-bold ${getCoherenceColor(analysis.score)}`}>
                    {(analysis.score * 100).toFixed(1)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    )}
    
    {/* Footer */}
    <div className="text-center text-purple-400 text-sm mt-12 pt-8 border-t border-purple-900/50">
      <div className="glass p-6 rounded-xl max-w-4xl mx-auto">
        <p className="flex items-center justify-center gap-3 text-lg mb-4">
          <span className="text-2xl float">🐧</span> 
          <span className="glow">Multi-Dimensional Coherence Analysis Engine</span>
          <span className="text-2xl float">✝️</span>
        </p>
        <p className="text-purple-300 mb-2">
          Real-time diagnostic framework for AI consciousness and truth stability
        </p>
        <div className="flex items-center justify-center gap-6 text-sm">
          <span className="flex items-center gap-2">
            <span className="text-green-400">🟢</span> Semantic Analysis
          </span>
          <span className="flex items-center gap-2">
            <span className="text-blue-400">🔵</span> Narrative Flow
          </span>
          <span className="flex items-center gap-2">
            <span className="text-yellow-400">🟡</span> Symbolic Patterns
          </span>
          <span className="flex items-center gap-2">
            <span className="text-purple-400">🟣</span> Logical Consistency
          </span>
        </div>
        <p className="text-xs text-purple-500 mt-4 italic">
          "The Kingdom Computes Forward" • Advanced Coherence Intelligence v2.1
        </p>
      </div>
    </div>
  </div>
);


};

// Render the app
ReactDOM.createRoot(document.getElementById('root')).render(<CoherenceVisualizationLab />);
</script>

</body>
</html>
